#define stm32f4xx
#include "stm32f4xx.h" // описание периферии
#include "stdio.h" // описание стандартных функций
#include "string.h" // библиотека работы со строками
#define CPU_CLOCK 1600000L // частота процессора
#define APB1_CLOCK 16000000L // частота шины APB1
#define APB2_CLOCK 16000000L // частота шины APB2
#define GPIO_AFRH_AF7_UART3_TX 0x7
#define GPIO_AFRH_AF7_UART3_RX 0x70
#include "DELAY_TIM7.h" // функции задержки
//#include "UART3_drv.h" // объявления функций для работы с USART3
char msg[130]; // массив для формирования сообщений для вывода по UART
volatile unsigned int Period; // измереный период
volatile unsigned int Dlit; // измеренная длительность
volatile unsigned long int measure_good = 0; // флаг: >= 2 - измерение готово, 0 - нет

/* функция передачи байта данных по UART*/
void UART3_TX_byte(char byte)
{
while(!(USART3->SR & USART_SR_TC)) {}; //USART_SR - регистр статуса usart, 6 бит устанавливается, если передача кадра завершена и режим TXE установлен.
USART3->DR = byte; // передаем байт
}

/*функция передачи строки данных по UART*/
void UART3_TX_string(char *str)
{
while((*str) != '\0') // проверяем на окончание строки
	{
	UART3_TX_byte(*str); // выводим текущий байт
	str++; //переходим на следующий символ
	}
}

int main(void)
{
// настройка UART
RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // запускаем тактовый генератор GPIOD
GPIOD->MODER |= GPIO_MODER_MODER8_1 | GPIO_MODER_MODER9_1; // настраиваем вывод PD8 и PD9 на альтернативную функцию
/*для конфигурирования пина8 в режим USART3_TX и пина9 в режим USART3_RX нужно в регистре GPIOD->AFR[1] выбрать комбинацию AF7 (стр.65 datasheet STM32F04xx)
для этого в регистр GPIOD->AFR[1] необходимо записать 0х7 и 0х70 соответственно*/
GPIOD->AFR[1] |= GPIO_AFRH_AF7_UART3_TX;
GPIOD->AFR[1] |= GPIO_AFRH_AF7_UART3_RX;
RCC->APB1ENR |= RCC_APB1ENR_USART3EN; // запускаем тактовый генератор USART3
USART3->CR1 |= USART_CR1_TE; // включить передатчик
USART3->CR1 |= USART_CR1_RE; // включить приемник
/*при сбросе по умолчанию параметры установлены 8N1 - 8 бит, без паритета, 1 стоп бит*/
/* расчет коэффициентов для требуемой скорости: тактовая частота 16 МГц. требуемая скорость 57600 бод/с.
USARTDIV = тактовая частота/(16 * требуемая скорость) = 16000000/(16*57600) = 17.36
"DIV_Mantissa" = 17 = 0x21; "DIV_Fraction" = 16*0.36 = 5.76; округляем до ближайшего целого - 6 = 0x06*/
USART3->BRR = (17 << 4) + 6; // скорость 57600 бод/с.
USART3->CR1 |= USART_CR1_UE; // включить USART
UART3_TX_string("Izmerenie Perioda i Dlitelnost Impulsa:\n\r");

// настройка порта D - выход ШИМа
//RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // включаем тактовый генератор порта D
GPIOD->MODER |= GPIO_MODER_MODER12_1; //настройка порта на альтернативную функцию TIM4, выход генератора - PD12
GPIOD->AFR[1] |= 0x00020000; // TIM4 - альтернативная функция AF2 для пина 12, 0010 в 16-19 биты

RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN; // включаем тактовый генератор порта С
GPIOC->MODER |= GPIO_MODER_MODER6_1;//настройка порта на альтернативную функцию TIM3, выход генератора - PC6
GPIOC->AFR[0] |= 0x2000000; // TIM3 - альтернативная функция AF2 для пина 6 порта С, 0010 в 24-27 бит

// настройка генератора ШИМ на TIM4
RCC->APB1ENR |= RCC_APB1ENR_TIM4EN; // включаем тактовый генератор TIM4
// тактовая частота таймера 16000000 Гц - период 0,0000000625
// Для получения времени 0,1 мсек (10 кГц частота ШИМ) выберем следующие параметры: 1/16000000Гц * 8 * 200 = 0,0001 сек
TIM4->PSC = 8-1; // делитель
TIM4->ARR = 200; // значение перезагрузки TIM4
TIM4->CCMR1 &= ~TIM_CCMR1_CC1S; // канал1 работает как выход
TIM4->CCMR1 |= TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1; // зададим режим ШИМ - 1
// полярность сигнала при сбросе установлена - положительная
TIM4->CCER |= TIM_CCER_CC1E; // разрешим вывод сигнала со схемы сравнения на вывод МК
TIM4->CCR1 = 50; // длительность ШИМ
TIM4->CR1 |= TIM_CR1_CEN; // разрешим работу таймера

// настройка генератора ШИМ на TIM3
RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; // включаем тактовый генератор TIM3
// тактовая частота таймера 16000000 Гц - период=0,0000000625 с
// Для получения времени 125 мксек (8 кГц частота ШИМ) выберем следующие параметры: 1/16000000Гц * 8 * 250 = 0,000125 сек
TIM3->PSC = 8-1; // делитель
TIM3->ARR = 250; // значение перезагрузки TIM3
TIM3->CCMR1 &= ~TIM_CCMR1_CC1S; // канал1 работает как выход
TIM3->CCMR1 |= TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1; // зададим режим ШИМ - 1
// полярность сигнала при сбросе установлена - положительная
TIM3->CCER |= TIM_CCER_CC1E; // разрешим вывод сигнала со схемы сравнения на вывод МК
TIM3->CCR1 = 51; // длительность ШИМ
TIM3->CR1 |= TIM_CR1_CEN; // разрешим работу таймера

// вход схемы захвата - PA0 и PA5 - TIM2 и TIM5
RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;// включаем тактовый генератор порта A
GPIOA->MODER |= GPIO_MODER_MODER5_1; // на альтернативную функцию
GPIOA->AFR[0] |= 0x100000; // TIM2 - альтернативная функция AF1 для пина 5
GPIOA->MODER |= GPIO_MODER_MODER0_1; // на альтернативную функцию
GPIOA->AFR[0] |= 0x2; // TIM5 - альтернативная функция AF2 для пина 0
//GPIOA->AFR[0] |= 0x1; // TIM2 - альтернативная функция AF1 для пина 5, 0001 в 0-3 бит

// настройка таймера TIM2 - измерителя ШИМ
RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; // включаем тактовый генератор TIM2
TIM2->ARR = 0xffffffff; // значение перезагрузки - максимальное значение для наибольшего диапазона счета
TIM2->CCMR1 |= TIM_CCMR1_CC1S_0; // //если канал1 работает в режиме захвата, сигнал захвата — TI1;
TIM2->CCMR1 |= TIM_CCMR1_CC2S_1; // //если канал2 работает в режиме захвата, сигнал захвата — TI1;
TIM2->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP); // выбираем захват канала 1 по переднему фронту импульса
TIM2->CCER &= ~TIM_CCER_CC2NP; //выбираем захват канала 2 по спадающему фронту
TIM2->CCER |= TIM_CCER_CC2P; //для этого в бит 5 записываем 1, в бит 7 - 0
TIM2->SMCR |= TIM_SMCR_TS_2 | TIM_SMCR_TS_0; // выберем триггер "Filtered Timer Input 1"- сигнал TI1 (после цифрового фильтра); TIMx_SMCR - регистр управления подчинённым режимом таймера;
TIM2->SMCR |= TIM_SMCR_SMS_2; // выберем режим ведомого - Reset Mode, режим сброса - нарастающий фронт сигнала на выбранном триггерном входе (TRGI) сбрасывает счётчик и обновляет регистры (100)
TIM2->DIER |= TIM_DIER_CC1IE; // разрешим прерывание при захвате/сравнении 1 канала
TIM2->DIER |= TIM_DIER_CC2IE; // разрешим прерывание при захвате/сравнении 2 канала
TIM2->CCER |= TIM_CCER_CC1E; // разрешим работу схемы захвата 1
TIM2->CCER |= TIM_CCER_CC2E; // разрешим работу схемы захвата 2
TIM2->CR1 |= TIM_CR1_CEN; // разрешим работу таймера
NVIC_EnableIRQ(TIM2_IRQn); // настройка NVIC для TIM2

// настройка таймера TIM5 - измерителя ШИМ
RCC->APB1ENR |= RCC_APB1ENR_TIM5EN; // включаем тактовый генератор TIM5
TIM5->ARR = 0xffffffff; // значение перезагрузки - максимальное значение для наибольшего диапазона счета
TIM5->CCMR1 |= TIM_CCMR1_CC1S_0; // //если канал1 работает в режиме захвата, сигнал захвата — TI1;
TIM5->CCMR1 |= TIM_CCMR1_CC2S_1; // //если канал2 работает в режиме захвата, сигнал захвата — TI1;
TIM5->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP); // выбираем захват канала 1 по переднему фронту импульса
TIM5->CCER &= ~TIM_CCER_CC2NP; //выбираем захват канала 2 по спадающему фронту
TIM5->CCER |= TIM_CCER_CC2P; //для этого в бит 5 записываем 1, в бит 7 - 0
TIM5->SMCR |= TIM_SMCR_TS_2 | TIM_SMCR_TS_0; // выберем триггер "Filtered Timer Input 1"- сигнал TI1 (после цифрового фильтра); TIMx_SMCR - регистр управления подчинённым режимом таймера;
TIM5->SMCR |= TIM_SMCR_SMS_2; // выберем режим ведомого - Reset Mode, режим сброса - нарастающий фронт сигнала на выбранном триггерном входе (TRGI) сбрасывает счётчик и обновляет регистры (100)
TIM5->DIER |= TIM_DIER_CC1IE; // разрешим прерывание при захвате/сравнении 1 канала
TIM5->DIER |= TIM_DIER_CC2IE; // разрешим прерывание при захвате/сравнении 2 канала
TIM5->CCER |= TIM_CCER_CC1E; // разрешим работу схемы захвата 1
TIM5->CCER |= TIM_CCER_CC2E; // разрешим работу схемы захвата 2
TIM5->CR1 |= TIM_CR1_CEN; // разрешим работу таймера
NVIC_EnableIRQ(TIM5_IRQn); // настройка NVIC для TIM5


// основной цикл программы
while(1)
{
if(measure_good > 2) // ждем окончания преобразования
	{
	sprintf(msg, "Period = %d mks, Length = %d mks\r\n", (Period/16), (Dlit/16)); // 1 такт таймера 1/16 мкс
	UART3_TX_string(msg);
	delay_ms(1000);
	}
}
}

// обработка прерываний от TIM2
void TIM2_IRQHandler(void)
{
// проверим, что сработал нужный флаг
if(TIM2->SR & TIM_SR_CC1IF)
	{
	TIM2->SR &= ~TIM_SR_CC1IF; // сбросим флаг прерывания
	Period = TIM2->CCR1; // измереный период
	// увеличиваем - измерение периода готово
	measure_good++; // флаг: 2 >= измерение готово, 0 - нет
	}
if(TIM2->SR & TIM_SR_CC2IF)
	{
	TIM2->SR &= ~TIM_SR_CC2IF; // сбросим флаг прерывания
	Dlit = TIM2->CCR2; // измеренная длительность
	// увеличиваем - измерение длительности готово
	measure_good++; // флаг: 2 >= измерение готово, 0 - нет
	}
}

// обработка прерываний от TIM5
void TIM5_IRQHandler(void)
{
// проверим, что сработал нужный флаг
if(TIM5->SR & TIM_SR_CC1IF)
	{
	TIM5->SR &= ~TIM_SR_CC1IF; // сбросим флаг прерывания
	Period = TIM5->CCR1; // измереный период
	// увеличиваем - измерение периода готово
	measure_good++; // флаг: 2 >= измерение готово, 0 - нет
	}
if(TIM5->SR & TIM_SR_CC2IF)
	{
	TIM5->SR &= ~TIM_SR_CC2IF; // сбросим флаг прерывания
	Dlit = TIM5->CCR2; // измеренная длительность
	// увеличиваем - измерение длительности готово
	measure_good++; // флаг: 2 >= измерение готово, 0 - нет
	}
}
