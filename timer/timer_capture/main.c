#define stm32f4xx
#include "stm32f4xx.h" // описание периферии
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#define GPIO_AFRH_AF7_UART3_TX 0x7
#define GPIO_AFRH_AF7_UART3_RX 0x70
#define GPIO_AFRH_PIN12_AF2 0x20000
#define GPIO_AFRL_PIN7_AF2 0x20000000

char msg[100]; // строка для вывода на UART
volatile unsigned int Period = 0; // измереный период
volatile unsigned int capture1 = 0, capture2; // значения захватов
volatile unsigned char Period_Flag = 0; // флаг для измерения периода

/* функция передачи байта данных по UART*/
void UART3_TX_byte(char byte)
{
while(!(USART3->SR & USART_SR_TC)) {}; //USART_SR - регистр статуса usart, 6 бит устанавливается, если передача кадра завершена и режим TXE установлен.
USART3->DR = byte; // передаем байт
}

/*функция передачи строки данных по UART*/
void UART3_TX_string(char *str)
{
while((*str) != '\0') // проверяем на окончание строки (символ 0x00)
	{
	UART3_TX_byte(*str); // выводим текущий байт
	str++; //переходим на следующий символ
	}
}

/*обработка прерываний от TIM3*/
void TIM3_IRQHandler(void)
{
TIM3->SR &= ~TIM_SR_CC2IF; /* сбросим флаг прерывания,
бит CC2IF при настройки таймера в режим capture равен "1", когда значение счетчика было записано в регистре TIMХ_CCR2*/
if(Period_Flag == 0) // флаг для измерения периода - первый импульс
	{
	capture1 = TIM3->CCR2; // первое значение захвата канала 2
	Period_Flag = 1; // флаг для измерения периода - второй импульс
	}
else
	if(Period_Flag == 1) // флаг для измерения периода - второй импульс
		{
		Period_Flag = 2; 
		Period = TIM3->CCR2 - capture1; // измереный период
		}
	else
		{
		TIM3->CNT = 0; // сбросим счетчик
		Period_Flag = 0; // флаг для измерения периода - первый импульс
		}
}

int main(void)
{
unsigned long int delay_cnt; // переменная для формирования задержки

// настройка UART
RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // запускаем тактовый генератор GPIOD
GPIOD->MODER |= GPIO_MODER_MODER8_1 | GPIO_MODER_MODER9_1; // настраиваем вывод PD8 и PD9 на альтернативную функцию
/*для конфигурирования пина8 в режим USART3_TX и пина9 в режим USART3_RX нужно в регистре GPIOD->AFR[1] выбрать комбинацию AF7 (стр.65 datasheet STM32F04xx)
для этого в регистр GPIOD->AFR[1] необходимо записать 0х7 и 0х70 соответственно*/
GPIOD->AFR[1] |= GPIO_AFRH_AF7_UART3_TX;
GPIOD->AFR[1] |= GPIO_AFRH_AF7_UART3_RX;
RCC->APB1ENR |= RCC_APB1ENR_USART3EN; // запускаем тактовый генератор USART3
USART3->CR1 |= USART_CR1_TE; // включить передатчик
USART3->CR1 |= USART_CR1_RE; // включить приемник
/*при сбросе по умолчанию параметры установлены (8N1 - 8 бит, без паритета, 1 стоп бит)*/
/* расчет коэффициентов для требуемой скорости: тактовая частота 16 МГц. требуемая скорость 57600 бод/с.
USARTDIV = тактовая частота/(16 * требуемая скорость) = 16000000/(16*57600) = 17.36
"DIV_Mantissa" = 17 = 0x21; "DIV_Fraction" = 16*0.36 = 5.76; округляем до ближайшего целого - 6 = 0x06*/
USART3->BRR = (17 << 4) + 6; // скорость 57600 бод/с.
USART3->CR1 |= USART_CR1_UE; // включить USART
UART3_TX_string("Izmerenie Perioda:\n\r");

// настройка вывода PD12 на альтернативную функцию выхода генератора TIM4_CH1
GPIOD->MODER |= GPIO_MODER_MODER12_1;
/* для конфигурирования пина12 в режим выхода TIM4_CH1, нужно в регистре GPIOD->AFR[1] выбрать комбинацию AF2
для этого в регистр GPIOD->AFR[1] необходимо записать 0х20000*/
GPIOD->AFR[1] |= GPIO_AFRH_PIN12_AF2;

// вход схемы захвата - пин PA7 (TIM3_CH2)
RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; // включаем тактовый генератор порта A
GPIOA->MODER |= GPIO_MODER_MODER7_1; // на альтернативную функцию
 /* для конфигурирования пина7 в режим входа TIM3_CH2, нужно в регистре GPIOD->AFR[0] выбрать комбинацию AF2
для этого в регистр GPIOD->AFR[0] необходимо записать 0х20000000*/
GPIOA->AFR[0] |= GPIO_AFRL_PIN7_AF2;

// настройка таймера TIM4
RCC->APB1ENR |= RCC_APB1ENR_TIM4EN; // включаем тактовый генератор TIM4
/* тактовая частота таймера 16000000 Гц - период 0,0000000625
Для получения времени 0,1 мсек (10 кГц часота ШИМ) выберем следующие параметры: (1/16000000Гц * 16 * 100 = 0,0001 сек*/
TIM4->PSC = 16-1; // делитель
TIM4->ARR = 200; // значение перезагрузки TIM4
// захват/сравнение при сбросе настроен как сравнение - на выход
TIM4->CCMR1 &= ~TIM_CCMR1_CC1S; // канал1 работает как выход
TIM4->CCMR1 |= TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1; //зададим режим PWM mode1 канала1. Если счетный регистр работает на сложение: при CNT<CCR1 сигнал OC1ref=1, иначе OC1ref=0.
// полярность сигнала при сбросе установлена - положительная
TIM4->CCER |= TIM_CCER_CC1E; // разрешим вывод сигнала со схемы сравнения на вывод МК
TIM4->CCR1 = 50; // длительность ШИМ, в данном режиме таймера TIM4->CCR1 - регистр сравнения
TIM4->CR1 |= TIM_CR1_CEN; // разрешим работу таймера

// настройка таймера TIM3
// режим захвата, CH2, 16 МГц /16 (делитель) = 1 МГц (1 мкс)
RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; // включаем тактовый генератор TIM3
TIM3->ARR = 0xffff; // значение перезагрузки (значение до которого считает таймер) - максимальное значение для наибольшего диапазона счета
TIM3->CCMR1 |= TIM_CCMR1_CC2S_0; //если канал2 работает в режиме захвата, сигнал захвата — TI1;
TIM3->CCER &= ~TIM_CCER_CC2P ;//выбираем захват по переднему фронту
TIM3->CCMR1 &= ~(TIM_CCMR1_IC2F | TIM_CCMR1_IC2PSC); //не фильтруем и делитель не используем
TIM3->CCER |= TIM_CCER_CC2E; // если канал2 настроен на вход, то разрешим работу схемы захвата
TIM3->DIER |= TIM_DIER_CC2IE; // разрешим прерывание при захвате/сравнении 2 канала
TIM3->CR1 |= TIM_CR1_CEN;  // разрешим работу таймера

NVIC_EnableIRQ(TIM3_IRQn); // настройка NVIC для TIM3
Period_Flag = 0; // флаг для измерения периода
__enable_irq(); // разрешим прерывания глобально

while(1)
{
// выводим значение периода
sprintf(msg, "Period = %d mks\r\n",(Period/16) - 1); // 1 такт таймера 1/16 мкс
UART3_TX_string(msg);
for(delay_cnt = 0; delay_cnt < 720000; delay_cnt++) {}; // задержка
}
}
